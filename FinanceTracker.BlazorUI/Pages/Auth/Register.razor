@page "/register"

@using FinanceTracker.BlazorUI.Models.Auth
@using FinanceTracker.BlazorUI.Models.Common
@using FinanceTracker.BlazorUI.Services.Auth
@inject AuthApiClient AuthApiClient
@inject NavigationManager NavigationManager
@inject ISnackbar Snackbar

<PageTitle>Register</PageTitle>

<MudGrid Justify="Justify.Center">
    <MudItem xs="12" sm="8" md="5" lg="4">
        <MudPaper Class="mt-10 pa-6" Elevation="4">
            <MudStack Spacing="2">
                <MudText Typo="Typo.h5" Align="Align.Center">
                    Create account
                </MudText>

                <MudText Typo="Typo.body2"
                         Align="Align.Center"
                         Color="Color.Primary">
                    Register to start tracking your finances
                </MudText>

                @if(_generalErrors.Length > 0)
                {
                    <MudAlert Severity="Severity.Error">
                        @foreach (var error in _generalErrors)
                        {
                            <div>@error</div>
                        }
                    </MudAlert>
                }

                <MudForm @ref="_form" Model="_model" @bind-IsValid="_isFormValid">
                    <MudStack Spacing="2">
                        <MudTextField T="string"
                                      Value="_model.UserName"
                                      ValueChanged="OnUserNameChanged"
                                      For="@(() => _model.UserName)"
                                      Label="Username"
                                      Variant="Variant.Outlined"
                                      Adornment="Adornment.Start"
                                      Required="true"
                                      RequiredError="Username is required" 
                                      Error="HasError(nameof(RegisterRequest.UserName))"
                                      ErrorText="@GetErrorText(nameof(RegisterRequest.UserName))"/>

                        <MudTextField T="string"
                                      Value="_model.Password"
                                      ValueChanged="OnPasswordChanged"
                                      For="@(() => _model.Password)"
                                      Label="Password"
                                      Variant="Variant.Outlined"
                                      Adornment="Adornment.Start"
                                      InputType="InputType.Password"
                                      Required="true"
                                      RequiredError="Password is required" 
                                      Error="HasError(nameof(RegisterRequest.Password))"
                                      ErrorText="@GetErrorText(nameof(RegisterRequest.Password))"/>

                        <MudButton Color="Color.Primary"
                                   Variant="Variant.Filled"
                                   FullWidth="true"
                                   Disabled="@(_isSubmitting || !_isFormValid)"
                                   OnClick="SubmitAsync">
                            @_buttonText
                        </MudButton>

                        <MudText Typo="Typo.body2" Align="Align.Center">
                            Already have an account?
                            <MudLink Href="/login">Login</MudLink>
                        </MudText>
                    </MudStack>
                </MudForm>
            </MudStack>
        </MudPaper>
    </MudItem>
</MudGrid>

@code
{
    private readonly RegisterRequest _model = new();
    private MudForm? _form;
    private bool _isSubmitting;
    private bool _isFormValid;

    // Server errors (validation, conflict, etc.)
    private readonly Dictionary<string, string[]> _fieldErrors = new(StringComparer.OrdinalIgnoreCase);
    private string[] _generalErrors = [];

    private string _buttonText => _isSubmitting ? "Registering..." : "Register";

    private async Task SubmitAsync()
    {
        _fieldErrors.Clear();
        _generalErrors = [];

        await _form!.Validate();
        if (!_isFormValid)
        {
            return;
        }

        _isSubmitting = true;

        try
        {
            var result = await AuthApiClient.RegisterAsync(_model);

            if (!result.IsSuccess)
            {
                SetErrors(result);
                return;
            }

            Snackbar.Add("Registration successful. You can login now.", Severity.Success);
            NavigationManager.NavigateTo("/login");
        }
        finally
        {
            _isSubmitting = false;
        }
    }

    private void OnUserNameChanged(string value)
    {
        _model.UserName = value;
        ClearFieldError(nameof(RegisterRequest.UserName));
    }

    private void OnPasswordChanged(string value)
    {
        _model.Password = value;
        ClearFieldError(nameof(RegisterRequest.Password));
    }

    private void ClearFieldError(string propertyName)
    {
        if (_fieldErrors.Remove(propertyName))
        {
            StateHasChanged();
        }
    }


    private void SetErrors(ApiResult result)
    {
        if (result?.FieldErrors?.Count > 0)
        {
            foreach (var kvp in result.FieldErrors)
            {
                var propertyName = MapToPropertyName(kvp.Key);
                _fieldErrors[propertyName] = kvp.Value;
            }
        }

        if (result?.GeneralErrors.Length > 0)
        {
            _generalErrors = result.GeneralErrors;
        }

        StateHasChanged();
    }

    private static string MapToPropertyName(string key)
    {
        return key.ToLowerInvariant() switch
        {
            "username" => nameof(RegisterRequest.UserName),
            "userName" => nameof(RegisterRequest.UserName),
            "password" => nameof(RegisterRequest.Password),
            _ => key
        };
    }

    private bool HasError(string propertyName)
    {
        return _fieldErrors.ContainsKey(propertyName);
    }

    private string GetErrorText(string propertyName)
    {
        return _fieldErrors.TryGetValue(propertyName, out var messages)
            ? string.Join("\n", messages)
            : string.Empty;
    }
}
